#!/usr/bin/env node

/**
 * Module dependencies.
 */

const program = require("commander");
const { spawn } = require("child_process");
const colors = require("colors");
const path = require("path");
const findUp = require("find-up");
const fs = require("fs");
const fetch = require("node-fetch");

const installPackage = async module => {
  const curDir = path.basename(process.cwd());
  if (curDir !== "frontend" && curDir !== "backend") {
    console.log(
      colors.red("Must be in the root of the frontend or backend directory")
    );
    return;
  }
  try {
    await runCommand("npm", ["install", "--save", module]);
    await runCommand("rm", ["-rf", "node_modules"]);
    await updateEnv();
    await runSingleCommand("docker-compose", ["down", "-v"]);
    await runSingleCommand("docker-compose", ["build"]);
  } catch (e) {
    console.log(e);
  }
};

const runSingleCommand = async (cmd, args, cb, env) => {
  try {
    await runCommand(cmd, args, cb, env);
  } catch (e) {
    console.log(e);
  }
};

const runCommand = (cmd, args, cb, env) => {
  return new Promise((res, rej) => {
    // spawn a new process
    const merged_env = { ...process.env, ...env };
    const proc = spawn(cmd, args, { env: merged_env });

    // pipe the output to the console
    proc.stdout.on("data", data => {
      process.stdout.write(data);
      if (cb) {
        cb(data.toString().split(/[\r\n]+/));
      }
    });

    proc.stderr.on("data", data => {
      process.stderr.write(data);
      if (cb) {
        cb(data.toString().split(/[\r\n]+/));
      }
    });

    proc.on("close", code => {
      const msg = `LAHUTIL: Command ${cmd} ${args.join(
        " "
      )} exited with code ${code}`;
      if (code === 0) {
        console.log(colors.green(msg));
        res(code);
      } else {
        console.error(colors.red(msg));
        rej(`Process error with exit code ${code}`);
      }
    });

    proc.on("error", code => {
      rej(code);
    });
  });
};

const removeAll = async () => {
  await runSingleCommand("docker", ["ps", "-a", "-q"], idArr => {
    // For every container running, stop it
    Promise.all(idArr.map(id => runSingleCommand("docker", ["stop", id])));
  });
  await runSingleCommand("docker", ["container", "ls", "-a", "-q"], idArr => {
    // For every container, remove it
    Promise.all(
      idArr.map(id => runSingleCommand("docker", ["container", "rm", "-f", id]))
    );
  });
  await runSingleCommand("docker", ["image", "ls", "-a", "-q"], idArr => {
    // For every image, remove it
    Promise.all(
      idArr.map(id => runSingleCommand("docker", ["image", "rm", "-f", id]))
    );
  });
  await runSingleCommand("docker", ["volume", "ls", "-q"], idArr => {
    // For every volume, remove it
    Promise.all(
      idArr.map(id => runSingleCommand("docker", ["volume", "rm", "-f", id]))
    );
  });
};

const updateEnv = async isWindows => {
  console.log(colors.blue("LAHUTIL: Attempting to sync up .env file..."));
  const envURLLoc = await findUp(".env_url");
  if (typeof envURLLoc === "undefined") {
    console.error(
      colors.red(
        "LAHUTIL: Cannot find .env_url - are you sure you have added it?"
      )
    );
  } else {
    const url = fs.readFileSync(envURLLoc, "utf8");
    const result = await (await fetch(url)).text();
    const dest = path.join(path.dirname(envURLLoc), ".env");
    fs.writeFileSync(dest, result);
    if (isWindows) {
      fs.appendFileSync(dest, "CHOKIDAR_USEPOLLING=true");
    }
    console.log(
      colors.green(
        "LAHUTIL: Successfully pulled current .env file from web server."
      )
    );
  }
};

const seedDB = async () => {
  console.log(
    colors.blue("LAHUTIL: Attempting to seed DB with sample data...")
  );
  await runSingleCommand("docker-compose", [
    "run",
    "backend",
    "node",
    "utils/generate_mock_data.js",
    "--colors"
  ]);
};

// error on unknown commands
program.on("command:*", function() {
  console.error(
    "Invalid command: %s\nType lahutil -h for a list of available commands.",
    program.args.join(" ")
  );
  process.exit(1);
});

program
  .version("0.0.1")
  .description(
    "A simple application for Life After Hate developers to manager their Docker containers without dealing with the extra overhead."
  );

program
  .command("up")
  .description(
    "Start up a new instance of the LAH frontend, backend, and database using Docker Compose."
  )
  .option("-n, --no-auth", "Running without auth enabled")
  .action(cmdObj =>
    runSingleCommand("docker-compose", ["up"], null, {
      BYPASS_AUTH: !cmdObj.auth
    })
  );

program
  .command("down")
  .description(
    "Stops the LAH frontend, backend, and database, and removes all DB information."
  )
  .action(() => {
    runSingleCommand("docker-compose", ["down", "-v"]);
  });

program
  .command("reset")
  .description(
    "Rebuilds everything â€” use this if you just pulled new changes and need to update your installed packages."
  )
  .action(async () => {
    await updateEnv();
    await runSingleCommand("docker-compose", ["down", "-v"]);
    await runSingleCommand("docker-compose", ["build"]);
  });

program
  .command("clearall")
  .description("Removes everything Docker-related. Only use as a last resort.")
  .action(async () => {
    await removeAll();
    // Do second pass in case there were any dependencies that couldn't be removed the first time
    await removeAll();
    console.log(colors.bgMagenta("Cleared all Docker-related files."));
  });

program
  .command("install <module>")
  .description("Installs module in directory")
  .action(installPackage);

program
  .command("env")
  .option("-w, --windows", "Is running docker for windows")
  .description(
    "Pulls latest .env file. Requires that you have the URL set it in .env_url"
  )
  .action(cmdObj => {
    updateEnv(cmdObj.windows);
  });

program
  .command("seed")
  .description("Seeds the database with the mock data")
  .action(seedDB);

program
  .command("test")
  .description("Runs backend testing suite")
  .action(() => runSingleCommand("docker-compose",["run","backend","npm","test"]));

if (!process.argv.slice(2).length) {
  program.outputHelp();
}

program.parse(process.argv);
